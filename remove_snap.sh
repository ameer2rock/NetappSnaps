#!/bin/bash
# remove Netapp CMode snapshot using WFA REST call
# UCG 1-16-2016
# requires curl, xmllint, credentials for WFA authorized AD account
# version history
# 1.0: initial

#Array Parameters
CLUSTER="sa0319nacl01"
VSERVER="svm0319nas04"
VOLUME="tst_automation"
#take snapshot name as passed parameter, if blank use variable defined value
SNAP_NAME=""
#Curl Parameters
# NOTE:  Domain user requires three slashes to be escaped correctly ie: nord\\\username
USER="xxxxx"
PASSWORD="xxxxx"
CURL="/usr/bin/curl"
CURL_TIMEOUT=180
#Timeout is for total length of transaction, so either failing to connect or failing to return a status within the total seconds allotted
XMLLINT="/usr/bin/xmllint"
URL="https://wfa/rest/workflows/e8604acc-ca6c-4ce6-b1d7-9909ddbc96de/jobs"
#URL is generated by WFA an is static once workflsow is created.
#Workflows are discovered by using: https://wfa/rest/workflows with a good authorization string
XML="./snapshot.xml"
CURL_OUT="./curl.out"
CURL_EXECUTE="./run.sh"
JOB_CHECK="./status_check.sh"
#Job check parameters
SLEEP_TIME=5
TRIES=12

#Functions

function is_file {
			if [ ! -f $1 ]
				then
					touch $1
			fi
			if [ -w $1 ]
				then
					return 0
				else
					echo "File: $1 not writable."
					exit 1
			fi
}

function create_xml {
echo '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' > $XML
echo ' <workflowInput> ' >> $XML
echo ' <userInputValues> ' >> $XML
echo " <userInputEntry key=\"Array\" value=\"$CLUSTER\"/> " >> $XML
echo " <userInputEntry key=\"Vserver\" value=\"$VSERVER\"/> " >> $XML
echo " <userInputEntry key=\"VolumeName\" value=\"$VOLUME\"/> " >> $XML
echo " <userInputEntry key=\"SnapshotName\" value=\"$SNAP_NAME\"/> " >> $XML
echo ' </userInputValues> ' >> $XML
echo ' </workflowInput> ' >> $XML
}

function clean_up {
			rm $JOB_CHECK $CURL_OUT $CURL_EXECUTE $XML
}

#MAIN
#check if snapshot name was passed to script
if [ ! -z $1 ]
	then 
	SNAP_NAME=$1
fi
if [ -z $SNAP_NAME ]
	then
	echo "No snapshot name defined."
	exit 1
fi
#generate snap XML
is_file $XML
create_xml
echo "==Generated snap XML request=="
cat $XML
#schedule snapshot removal
is_file $CURL_OUT
is_file $CURL_EXECUTE
echo "$CURL -s --insecure -m $CURL_TIMEOUT -H \"Content-Type:application/xml\" -o $CURL_OUT -u $USER:$PASSWORD --anyauth -d @$XML -X POST $URL" > $CURL_EXECUTE
eval chmod 700 $CURL_EXECUTE
eval $CURL_EXECUTE
#confirm that request gets a "SCHEDULED" return from WFA
SUBMIT_STATE=`xmllint --format $CURL_OUT | awk 'BEGIN{FS="[<|>]"} /<jobStatus>/ && /<\/jobStatus>/ {print $3}' `
if [ "$SUBMIT_STATE" != "SCHEDULED" ]
		then
			echo "Job schedule failed with status: $SUBMIT_STATE"
			exit 1
		else
			echo "Job was succesfully SCHEDULED."
		fi
#job execution is asynchronous; generate a string to query the state of this specific job request.
#loop until job reaches "COMPLETED" state or we exceed the tries and error out.
#In testing, it takes 5-10 seconds to schedule the snap delete and get a COMPLETED result.
is_file $JOB_CHECK
JOB_CHECK_URL=`xmllint --format $CURL_OUT | awk 'BEGIN{FS="\""} /<atom:link rel="self"/ && /jobs/ {print $4}' `
echo "$CURL -s --insecure -m $CURL_TIMEOUT -H \"Content-Type:application/xml\" -o $CURL_OUT -u $USER:$PASSWORD --anyauth -d @$XML -X GET $JOB_CHECK_URL" > $JOB_CHECK
chmod 700 $JOB_CHECK
sleep $SLEEP_TIME
for i in $(seq 1 $TRIES)
do
		 ./$JOB_CHECK
		 JOB_STATUS=`xmllint --format $CURL_OUT | awk 'BEGIN{FS="[<|>]"} /<jobStatus>/ && /<\/jobStatus>/ {print $3}' `
		 if [ $JOB_STATUS == "COMPLETED" ]
			 then
			 		echo "Job completed."
					clean_up
					exit 0
			 else
				  echo "Status: $JOB_STATUS"
			 fi
	 sleep $SLEEP_TIME
done
echo "Job failed to reach completed status.  Last status $JOB_STATUS"
exit 1
