#!/bin/bash
# update Netapp snapmirror snapshot using WFA REST call
# UCG 1-26-2016
# requires curl, xmllint, credentials for WFA authorized AD account
# Snapmirror destination volume and initializtion must be completed prior to running or it will fail
# version history
# 1.0: initial

#Array Parameters

DEST_CLUSTER="sa0319nacl01"
DEST_VOLUME="tst_automation_m1"
DEST_VSERVER="svm0319nas06"

#Curl Parameters
USER="xxxxx"
PASSWORD="xxxxx"
CURL="/usr/bin/curl"
CURL_TIMEOUT=180
#Timeout is for total length of transaction, so either failing to connect or failing to return a status within the total seconds allotted
XMLLINT="/usr/bin/xmllint"
URL="https://wfa/rest/workflows/5532001d-c83c-458d-b5ec-edfb4a79c6aa/jobs"
#URL is generated by WFA an is static once workflsow is created.
#Workflows are discovered by using: https://wfa/rest/workflows with a good authorization string
XML="./snapshot.xml"
CURL_OUT="./curl.out"
CURL_EXECUTE="./run.sh"
JOB_CHECK="./status_check.sh"
#Job check parameters
SLEEP_TIME=1
TRIES=240

#Functions

function is_file {
			if [ ! -f $1 ]
				then
					touch $1
			fi
			if [ -w $1 ]
				then
					return 0
				else
					echo "File: $1 not writable."
					exit 1
			fi
}

function create_xml {
echo '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' > $XML
echo ' <workflowInput> ' >> $XML
echo ' <userInputValues> ' >> $XML
echo " <userInputEntry key=\"DestinationCluster\" value=\"$DEST_CLUSTER\"/> " >> $XML
echo " <userInputEntry key=\"DestinationVserver\" value=\"$DEST_VSERVER\"/> " >> $XML
echo " <userInputEntry key=\"DestinationVolume\" value=\"$DEST_VOLUME\"/> " >> $XML
echo ' </userInputValues> ' >> $XML
echo ' </workflowInput> ' >> $XML
}

function clean_up {
			rm $JOB_CHECK $CURL_OUT $CURL_EXECUTE $XML
}

#MAIN

#generate snap XML
is_file $XML
create_xml
echo "==Generated snap XML request=="
cat $XML
#schedule snapshot request
is_file $CURL_OUT
is_file $CURL_EXECUTE
echo "$CURL -s --insecure -m $CURL_TIMEOUT -H \"Content-Type:application/xml\" -o $CURL_OUT -u $USER:$PASSWORD --anyauth -d @$XML -X POST $URL" > $CURL_EXECUTE
eval chmod 700 $CURL_EXECUTE
eval $CURL_EXECUTE
#confirm that request gets a "SCHEDULED" return from WFA
SUBMIT_STATE=`xmllint --format $CURL_OUT | awk 'BEGIN{FS="[<|>]"} /<jobStatus>/ && /<\/jobStatus>/ {print $3}' `
if [ "$SUBMIT_STATE" != "SCHEDULED" ]
		then
			echo "Job schedule failed with status: $SUBMIT_STATE"
			exit 1
		else
			echo "Job was succesfully SCHEDULED."
		fi
#job execution is asynchronous; generate a string to query the state of this specific job request.
#loop until job reaches "COMPLETED" state or we exceed the tries and error out.
#In testing, it takes 10-15 seconds to schedule the snap and get a COMPLETED result.
is_file $JOB_CHECK
JOB_CHECK_URL=`xmllint --format $CURL_OUT | awk 'BEGIN{FS="\""} /<atom:link rel="self"/ && /jobs/ {print $4}' `
echo "$CURL -s --insecure -m $CURL_TIMEOUT -H \"Content-Type:application/xml\" -o $CURL_OUT -u $USER:$PASSWORD --anyauth -d @$XML -X GET $JOB_CHECK_URL" > $JOB_CHECK
chmod 700 $JOB_CHECK
sleep $SLEEP_TIME
for i in $(seq 1 $TRIES)
do
		 ./$JOB_CHECK
		 JOB_STATUS=`xmllint --format $CURL_OUT | awk 'BEGIN{FS="[<|>]"} /<jobStatus>/ && /<\/jobStatus>/ {print $3}' `
		 case $JOB_STATUS in
			 COMPLETED)
			 				echo "Job completed succesfully at `date`"
							clean_up
							exit 0
							;;
			 FAILED)
			 				echo "Job failed, examine output files."
							exit 1
							;;
			 *)
			 				echo "Job status:  $JOB_STATUS at `date`"
			esac
	 sleep $SLEEP_TIME
done
echo "Job failed to reach completed status.  Last status $JOB_STATUS"
exit 1
